I"å<p>Today, Micah asked me to use four Ruby code analysis tools on my Ruby tic tac toe program. I was excited about this, because I have never used any code analysis tools before, and I was curious to see how my code would fare.</p>

<p>The first tool I used was <a href="https://github.com/colszowka/simplecov">SimpleCov</a>. It measures <a href="http://en.wikipedia.org/wiki/Code_coverage">code coverage</a>, and like most things related to software development, is a topic that could be studied in depth on its own. What is particularly great about SimpleCov is that after applying its heuristics in determining how well your tests actually cover your code, the tool generates a nicely formatted html doc that displays a summarized result. Every file is given a percentage of coverage, so that files with weak coverage can be easily found prompting the developer to write more comprehensive tests. Being so new to TDD, I wasn‚Äôt expecting great scores, but I was happy to see the overall average of coverage for my tic tac toe program was around 90%.</p>

<p>The next tool I used was <a href="https://github.com/seattlerb/flay">Flay</a>. It looks at the structure of your code and helps identify portions of duplicated code, or methods that structurally behave in similar ways to other methods, possibly allowing for refactoring of those methods into slimmer, cleaner methods. The output of this tool wasn‚Äôt as impressive as SimpleCov, but I was happy to see that only my presenter class registered as a good candidate for refactoring. Throughout writing this program I tried to maintain a strict object boundary between the game logic and the output and input, but there are parts of my presenter class that I can see are smelly. I struggled to think of ways of maintaining this boundary, so I used <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> to help contain the passing of messages from certain parts of the application to my presenter object. Still, I feel like I‚Äôm not quite seeing how best to do this, and is something I‚Äôm looking forward to talking with Micah about. After running the Flay analysis, it was affirming to see a result that confirmed what I already perceived as being a weakness of my application‚Äôs design. Afterall, the first step to solving a problem is first knowing what the problem is.</p>

<p>After Flay, I used <a href="https://github.com/seattlerb/flog">Flog</a>. Ruby has a certain reputation for having a wide and diverse collection of <a href="http://en.wikipedia.org/wiki/RubyGems">gems</a>. Basically a gem is a library or a package that can be added to an application‚Äôs environment. Some gem names are fun and descriptive: <a href="https://github.com/jnunemaker/httparty">httparty</a>, while others are neither: <a href="https://github.com/forward/mandy">Mandy</a>. Ruby also has some easy to use tools for managing gems and versions of Ruby. If you‚Äôre new to Ruby and are curious how that works, both <a href="http://gembundler.com/">Bundler</a> and <a href="https://rvm.io/">RVM</a> are considered essential tools, although lately I‚Äôve been meeting more and more Rubyists who prefer using <a href="https://github.com/sstephenson/rbenv">rbenv</a> (for various reasons, including wanting to use <a href="http://ridiculousfish.com/shell/">Fish</a> or <a href="http://friedcpu.wordpress.com/2007/07/24/zsh-the-last-shell-youll-ever-need/">Zsh</a> shells (RVM only works in <a href="http://www.gnu.org/software/bash/manual/bashref.html#What-is-Bash_003f">bash</a>, or because RVM is sometimes criticized for changing aspects of the shell environment ‚Äì for more on the differences, I found this <a href="http://jonathan-jackson.net/rvm-and-rbenv">post</a> highly entertaining).</p>

<p>Flog‚Äôs job was to use an ABC Metric to analyze code size and return a score of how ‚Äúpainful‚Äù the code is. The higher the score, the more flogging a developer‚Äôs mind will have to take in order to navigate and understand that code. One breakdown I found to help see how good or bad my flog score was is this short <a href="http://jakescruggs.blogspot.com/2008/08/whats-good-flog-score.html">post</a>. Before running Flog, I was expecting the AI class to have the highest flog score, because it contains the minimax method. Minimax is the longest method with the most branching I have in the tic tac toe application. I was pleased to see the averaged flog score for my application was better than I expected, and not surprised that my minimax method received the highest flog score.</p>

<p>The first three tools were fairly straightforward to implement, but <a href="https://github.com/devver/saikuro">Saikuro</a> was a little more challenging because it is incompatible with Ruby 1.9 (the current version of Ruby). Switching to Ruby 1.8.7 was no big deal, and after verifying Saikuro‚Äôs executable file was in my load path, it was smooth sailing. Saikuro is a <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity analyzer</a>, and measures code complexity. I don‚Äôt really understand how cyclomatic complexity analysis works, but from the basic understanding I have I started imagining a tool that could represent a cyclomatic complexity analysis as a visual graph, showing how various parts of the application connect to each other as <a href="http://en.wikipedia.org/wiki/Graph_theory">nodes of a graph</a> (perhaps something to try at a future Waza). I didn‚Äôt expect much in my tic tac toe program to produce a high complexity score, except for the minimax method - which my Saikuro results confirmed. This tool was the most opaque to use, as I was never able to successfully use the -h flag in order to see its help explanation (I was curious to see what flags it offers in order to learn more about its functionality).</p>

<p>These tools were fun to learn about, and they introduced me to several new ideas. I had never heard of a cyclomatic complexity analyzer or ABC metric before today, and these tools gave me new ways to think about and break apart my code in order to find the <a href="http://en.wikipedia.org/wiki/Code_smell">smelly spots</a>. However, the real measure of how I did will come from code review with Micah. I‚Äôm very excited to have my code dissected and have someone with many years of experience shine a light on the parts that could be better. As an apprentice, I hope to soak up and learn as much as possible from my mentor, and the people around me who have already traversed the hill.</p>
:ET